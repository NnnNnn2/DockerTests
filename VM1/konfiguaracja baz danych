# Uruchom poniższą komendę na VM1, aby połączyć się z kontenerem ProxySQL:
docker exec -it proxysql_ha mysql -u admin -padmin -h 127.0.0.1 -P 6032

# Dodanie IP serwerów MySQL na VM2 i VM3

-- 1. Dodanie Mastera (VM2) do grupy 10 (Writer)
INSERT INTO mysql_servers (hostgroup_id, hostname, port) 
VALUES (10, '192.168.100.6', 3306);

-- 2. Dodanie Slave'a (VM3) do grupy 10, proxySQL przenisie go do 20 (Reader/Fallback)
INSERT INTO mysql_servers (hostgroup_id, hostname, port) 
VALUES (10, '192.168.100.7', 3306);

-- 3. Ustawienie użytkownika WordPressa. 
-- Domyślnie ProxySQL kieruje ruch do hostgroup 10 (Master)
INSERT INTO mysql_users (username, password, default_hostgroup) 
VALUES ('wordpress_user', 'wordpress_password', 10);

-- 4. Konfiguracja przełączania awaryjnego i replikacji
-- Mówimy ProxySQL: Writerzy są w 10, czytelnicy/zapasowi są w 20.
-- Użyj wbudowanej funkcji 'mysql_slave_status' do monitorowania replikacji.
INSERT INTO mysql_replication_hostgroups (writer_hostgroup, reader_hostgroup, check_type)
VALUES (10, 20, 'read_only');

-- Opcjonalnie: Ustawienie limitu opóźnienia replikacji (seconds_behind_master).
-- Jeśli Slave opóźni się o 60 sekund, ProxySQL przestanie wysyłać do niego ruch (w roli Readera).
UPDATE global_variables SET variable_value='60' WHERE variable_name='mysql-monitor_replication_lag_threshold';

-- 5. Wstawienie do schedulera naszego skryptu wyłączającego read_only VM3 w przypadku awarii VM2
INSERT INTO scheduler (id, active, interval_ms, filename) 
VALUES (1, 1, 2000, '/usr/local/bin/failover_safe.sh');

LOAD MYSQL SERVERS TO RUNTIME;
LOAD MYSQL USERS TO RUNTIME;
LOAD MYSQL VARIABLES TO RUNTIME;
SAVE MYSQL SERVERS TO DISK;
SAVE MYSQL USERS TO DISK;
SAVE MYSQL VARIABLES TO DISK;
LOAD SCHEDULER TO RUNTIME;
SAVE SCHEDULER TO DISK;

exit


-- Na koniec sprawdź status serwerów
docker exec -it proxysql_ha mysql -u admin -padmin -h 127.0.0.1 -P 6032 -e "SELECT hostgroup_id, hostname, status, weight FROM runtime_mysql_servers;"
